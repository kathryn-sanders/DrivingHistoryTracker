# DrivingHistoryTracker

To approach this problem, I chose to use an object-oriented language (C#) because that is what I'm most familiar with. I started by setting up some of the classes I knew I was going to need. I knew I was going to need a class for File Access, to isolate the part of the application that wasn't easily testable. Based on the expected input that would either establish a new driver, or record a trip, I also know that I would need a Driver and Trip class to handle that input. 

I knew that the input data starting with a trip command would include the driver name, start and stop time, and miles driven, so I added those as properties. I originally tried to use DateTime as the data type for start and stop time, knowing that I would have to calculate the duration of the trip at some point and hoping that DateTime came with some simple methods for doing so. I also knew that I was going to have to discard any trips that had an average speed of less than 5 mph, or greater than 100 mph, so I was going to need a property for average trip speed. In order to calculate the speed, I needed to divide the miles driven by the duration, and before I handled that calculation, I needed to calculate the trip duration. Upon closer inspection, I couldn't find any built in methods for DateTime allowing for an easy subtraction of the StartTime from the StopTime, but some investigation led me to the datatype TimeSpan, which allowed for a much easier and more direct calculation of the duration in minutes. Now that I had trip duration, I could calculate average trip speed by dividing the miles driven by the duration (in minutes), then multiplying that by 60 in order to convert from miles per minute, to miles per hour. 

Next, I looked into the Driver class. I knew that I needed a property for driver name, since that was in the expected input with the driver command. I also knew that I was going to need a property for total miles driven and average speed for any given driver for my output. I also knew that in order to calculate average speed, I was going to need to first calculate the the total time driven.

As the application is run from the command line, a user must also specify a filepath for the input file. I then use a stream reader in my file access class to add each line of data from the input file into a list of strings. This list is then passed back to Program.cs and assigned to a list that I called rawFileData. From here, I added a wrapper class, DrivingRecord, as the place where most of the work pertaining to the input logs would be completed. Driving record is also where I used a dictionary, DriverOverview, to store my data for the duration of the program. I used the driver name as a string as the key, and used a driver object as the value, but realistically, I would use a database to store this information.

I needed a way to analyse each line to see which command it started with, so I created a constructor in Driving Record that would take in the rawFileData and split it by spaces into a string array. Then, the application looked at element 0 of the array. If it began with driver, a new driver object was created, passing the driver's name into the constructor of driver, which created a new driver object. Here I also instantiated another list of trip objects in order to temporarily store all the trips associated with a driver. 

If the line command was trip, I passed the data into the trip constructor, which parsed the strings into more usable datatypes and assigned them to properties. The average speed of the trip is checked next, and as long as it is greater than 5 mph, and less than 100 mph, the trip is is added to the trip history list of a driver by looking up the driver name in the DriverOverview dictionary. 

The next thing I worked on was using a stream writer to record the requested output from the driver overview. The user can either specify a filepath for the output at the time the program is run from the command line, or if no filepath is provided, the application will create an output file in the current directory and print that file path to the console. 

Once the application was successfully creating an output file, I needed a way to sort the output by most total miles driven. I accomplished this using LINQ to order by descending my original DriverOverview dictionary the value TotalMilesDriven and assigning the results to a list of key/value pairs. I then put these sorted key value pairs back into a dictionary so the data for the value (the driver object) could be accessed by the stream writer. 

I began by testing that the constructor in my trip class was working correctly. These tests also ensured that my derived properties were making the correct calculations. These tests revealed that in the AvgTripSpeed calculation, I had accidentally divided by 60 instead of multiplying by 60 to turn miles per minute into miles per hour. These tests also revealed that I had no way to handle if the duration of a trip was 0. After adding logic to solve this, I moved on to testing the Driver and DrivingRecord classes.
